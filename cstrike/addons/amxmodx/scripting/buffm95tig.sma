/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <cstrike>
#include <engine>
#include <amxmisc>
#include <fun>
#include <hamsandwich>
#include <xs>
#include <fakemeta>
#include <fakemeta_util>
#include <gunxpmod>

#define PLUGIN "Buffm95 (White Tiger)"
#define VERSION "1.0"
#define AUTHOR "HAHAHA"

#define CSW_BUFFM95 CSW_AWP
#define weapon_buffm95 "weapon_awp"
#define weaponevent "events/awp.sc"
#define old_w_model "models/w_awp.mdl"
#define weapon_code 991092990

#define DAMAGE 120
#define DAMAGE_CLAW 540.0
#define CLIP 20
#define BPAMMO 136
#define RECOIL 0.75
#define RELOAD_TIME 2.0
#define SPEED 1.2

#define AMMO_SPC 7

#define INSTANCE(%0) ((%0 == -1) ? 0 : %0)
#define IsValidPev(%0) (pev_valid(%0) == 2)
#define IsObserver(%0) pev(%0,pev_iuser1)
#define OBS_IN_EYE 4

const PRIMARY_WEAPONS_BIT_SUM = (1<<CSW_SCOUT)|(1<<CSW_XM1014)|(1<<CSW_MAC10)|(1<<CSW_AUG)|(1<<CSW_UMP45)|(1<<CSW_SG550)|(1<<CSW_GALIL)|(1<<CSW_FAMAS)|(1<<CSW_AWP)|(1<<CSW_MP5NAVY)|(1<<CSW_M249)|(1<<CSW_M3)|(1<<CSW_M4A1)|(1<<CSW_TMP)|(1<<CSW_G3SG1)|(1<<CSW_SG552)|(1<<CSW_AK47)|(1<<CSW_P90)
const SECONDARY_WEAPONS_BIT_SUM = (1<<CSW_P228)|(1<<CSW_ELITE)|(1<<CSW_FIVESEVEN)|(1<<CSW_USP)|(1<<CSW_GLOCK18)|(1<<CSW_DEAGLE)

const PDATA_SAFE = 2
const OFFSET_LINUX_WEAPONS = 4
const OFFSET_LINUX_PLAYER = 5
const OFFSET_WEAPONOWNER = 41
const m_iClip = 51
const m_fInReload = 54
const m_flNextAttack = 83
const m_szAnimExtention = 492

new const model[][] = {
	"models/p_m95tiger.mdl",
	"models/v_m95tiger.mdl",
	"models/w_m95tiger.mdl",
	"models/ef_m95tiger.mdl",
	"models/ef_m95tiger_net.mdl",
	"models/ef_m95tiger_nethit.mdl"
}
new const sound[][] = {
	"weapons/m95tiger_clipin.wav",
	"weapons/m95tiger_clipout.wav",
	"weapons/m95tiger_draw.wav",
	"weapons/m95tiger_idle.wav",
	"weapons/m95tiger_reloadb.wav",
	"weapons/m95tiger_tiger.wav",
	"weapons/m95tiger-1.wav",
	"weapons/m95tiger-2.wav",
	"weapons/m95tiger-3.wav",
	"weapons/shoot_net1.wav",
	"weapons/shoot_net2.wav"
}
new const sprites[][] = {
	"sprites/640hud19.spr",
	"sprites/640hud43.spr",
	"sprites/640hud183.spr",
	"sprites/weapon_m95tiger.txt",
	"sprites/muzzleflash80.spr",
	"sprites/m95tiger_scope_grenade.spr",
	"sprites/ef_m95tiger_scratch.spr"
}
enum
{
	SHOOT_NORMAL = 0,
	SHOOT_NET,
	SHOOT_TIGER
}
new g_had_buffm95[33], g_buffm95_event, g_smokepuff_id, m_iBlood[2], g_ham_bot, g_buffm95_clip[33]
new Float:g_punchangles[33][3],g_Beam_SprId, g_Msg_StatusIcon, g_hit, g_InStuck[33]
new g_InZoom[33], g_ammo_spc[33], g_AttackType[33], g_Froze[33]
new iCount, CanSummon
public plugin_init() {
	register_plugin(PLUGIN, VERSION, AUTHOR)
	
	register_gxm_item("[AWP] White Tiger M95", "", 8000, 50, GUN_SECTION_RIFLE, 0, CSW_AWP)
	
	register_event("CurWeapon", "Event_CurWeapon", "be", "1=1")
	register_forward(FM_SetModel, "fw_SetModel")
	register_forward(FM_UpdateClientData, "fw_UpdateClientData_Post", 1)
	register_forward(FM_PlaybackEvent, "fw_PlaybackEvent")
	register_forward(FM_ClientCommand, "fw_Client_Command")
	
	register_think("mf_buffm95", "fw_Muzzle_Think")
	register_think("net_hit", "fw_think_nethit")
	register_think("net_shot", "fw_think_net")
	register_touch("net_shot", "*", "fw_touch_net")
	register_think("ef_tiger", "fw_tgr_think")
	register_touch("ef_tiger", "*", "fw_tgr_touch")
	
	RegisterHam(Ham_TraceAttack, "worldspawn", "fw_TraceAttack")
	RegisterHam(Ham_TraceAttack, "player", "fw_TraceAttack")
	RegisterHam(Ham_TraceAttack, "player", "fw_TraceAttack_Post", 1)
	
	RegisterHam(Ham_Item_Deploy, weapon_buffm95, "fw_Item_Deploy_Post", 1)
	RegisterHam(Ham_Weapon_WeaponIdle, weapon_buffm95, "fw_Item_Idle_Post", 1)
	RegisterHam(Ham_Weapon_Reload, weapon_buffm95, "fw_Weapon_Reload_Pre")
	RegisterHam(Ham_Weapon_Reload, weapon_buffm95, "fw_Weapon_Reload_Post", 1)
	RegisterHam(Ham_Item_PostFrame, weapon_buffm95, "fw_Item_PostFrame")
	RegisterHam(Ham_Item_AddToPlayer, weapon_buffm95, "fw_Item_AddToPlayer_Post", 1)
	RegisterHam(Ham_Weapon_PrimaryAttack, weapon_buffm95, "fw_Weapon_PrimaryAttack_Pre")
	RegisterHam(Ham_Weapon_PrimaryAttack, weapon_buffm95, "fw_Weapon_PrimaryAttack_Post", 1)
	
	g_Msg_StatusIcon = get_user_msgid("StatusIcon")
	
	register_clcmd("get_buffm95", "get_m85tiger")
	register_clcmd("weapon_buffm95", "hook_weapon")
}

public plugin_precache()
{
	new i;
	for(i = 0; i <sizeof(model); i++)
		engfunc(EngFunc_PrecacheModel, model[i])
	for(i = 0; i <sizeof(sound); i++)
		engfunc(EngFunc_PrecacheSound, sound[i])
	for(i = 0; i <sizeof(sprites); i++)
		if(i == 3)engfunc(EngFunc_PrecacheGeneric, sprites[i])
		else engfunc(EngFunc_PrecacheModel, sprites[i])
	
	g_smokepuff_id = engfunc(EngFunc_PrecacheModel, "sprites/wall_puff1.spr")
	m_iBlood[0] = engfunc(EngFunc_PrecacheModel, "sprites/blood.spr")
	m_iBlood[1] = engfunc(EngFunc_PrecacheModel, "sprites/bloodspray.spr")
	g_Beam_SprId =  engfunc(EngFunc_PrecacheModel, "sprites/laserbeam.spr")
	g_hit = engfunc(EngFunc_PrecacheModel, "sprites/ef_m95tiger_scratch.spr")
	
	register_forward(FM_PrecacheEvent, "fw_PrecacheEvent_Post", 1)
}
public fw_PrecacheEvent_Post(type, const name[])
{
	if(equal(weaponevent, name))
		g_buffm95_event = get_orig_retval()
}

public client_putinserver(id)
{
	if(is_user_bot(id) && !g_ham_bot)
	{
		g_ham_bot = 1
		set_task(0.1, "Do_Register_Ham", id)
	}
}

public Do_Register_Ham(id)
{
	RegisterHamFromEntity(Ham_TraceAttack, id, "fw_TraceAttack")
	RegisterHamFromEntity(Ham_TraceAttack, id, "fw_TraceAttack_Post", 1)
}

public gxm_item_enabled(id)
{	
//	drop_weapons(id, 1)
	g_had_buffm95[id] = 1
	iCount = 10
	CanSummon = 0
	g_InZoom[id] = 0
	g_ammo_spc[id] = AMMO_SPC
	g_AttackType[id] = SHOOT_NORMAL
	ShowStatusIcon(id, g_ammo_spc[id], 1)
	static ent; ent = fm_get_user_weapon_entity(id, CSW_BUFFM95)
	if(pev_valid(ent)) cs_set_weapon_ammo(ent, CLIP)
	
	if(get_user_weapon(id) == CSW_BUFFM95)Event_CurWeapon(id)
	else client_cmd(id, weapon_buffm95)
	
	// Set BpAmmo
	cs_set_user_bpammo(id, CSW_BUFFM95, BPAMMO)
}

public client_connect(id)
{
	remove_m95tiger(id)
}

public remove_m95tiger(id)
{
	g_had_buffm95[id] = 0
	HideStatusIcon(id)
}
public hook_weapon(id)
{
	client_cmd(id, weapon_buffm95)
	return PLUGIN_HANDLED
}
public Event_CurWeapon(id)
{
	if(!is_user_alive(id))
		return
	if(get_user_weapon(id) != CSW_BUFFM95 || !g_had_buffm95[id])
	{
		HideStatusIcon(id)
		StopSound(id)
		set_fov(id, 90)
		return
	}
	ShowStatusIcon(id, g_ammo_spc[id], 1)
	// Speed
	static ent; ent = fm_get_user_weapon_entity(id, CSW_BUFFM95)
	if(!pev_valid(ent)) 
		return
	
	set_pev(id, pev_viewmodel2, model[1])
	set_pev(id, pev_weaponmodel2, model[0])
}
public fw_SetModel(entity, model[])
{
	if(!pev_valid(entity))
		return FMRES_IGNORED
	
	static szClassName[33]
	pev(entity, pev_classname, szClassName, charsmax(szClassName))
	
	if(!equal(szClassName, "weaponbox"))
		return FMRES_IGNORED
	
	static id
	id = pev(entity, pev_owner)
	
	if(equal(model, old_w_model))
	{
		static weapon
		weapon = fm_find_ent_by_owner(-1, weapon_buffm95, entity)
		
		if(!pev_valid(weapon))
			return FMRES_IGNORED
		
		if(g_had_buffm95[id])
		{
			set_pev(weapon, pev_impulse, weapon_code)
			engfunc(EngFunc_SetModel, entity, "models/w_m95tiger.mdl")
			
			return FMRES_SUPERCEDE
		}
	}

	return FMRES_IGNORED
}
public fw_TraceAttack(ent, attacker, Float:Damage, Float:fDir[3], ptr, iDamageType)
{
	if(!is_user_alive(attacker))
		return HAM_IGNORED	
	if(get_user_weapon(attacker) != CSW_BUFFM95 || !g_had_buffm95[attacker])
		return HAM_IGNORED
		
	if(!is_user_alive(ent))
	{
		static Float:flEnd[3], Float:vecPlane[3]
		get_tr2(ptr, TR_vecEndPos, flEnd)
		get_tr2(ptr, TR_vecPlaneNormal, vecPlane)		
		
		static Float:Target[3]; 
		fm_get_aim_origin(attacker, Target)
			
		set_tr2(ptr, TR_vecEndPos, Target)
			
		get_tr2(ptr, TR_vecEndPos, flEnd)
		make_bullet(attacker, flEnd)
		fake_smoke(attacker, ptr)
	}
	SetHamParamFloat(3, DAMAGE+2.5)	

	return HAM_HANDLED
}
public fw_TraceAttack_Post(Ent, Attacker, Float:Damage, Float:Dir[3], ptr, DamageType)
{
	if(!is_user_connected(Attacker))
		return HAM_IGNORED	
	if(get_user_weapon(Attacker) != CSW_BUFFM95 || !g_had_buffm95[Attacker])
		return HAM_IGNORED
	if(cs_get_user_team(Ent) == cs_get_user_team(Attacker))
		return HAM_IGNORED
		
	if (!(DamageType & DMG_BULLET))
		return HAM_IGNORED
	if (Damage <= 0.0 || GetHamReturnStatus() == HAM_SUPERCEDE || get_tr2(ptr, TR_pHit) != Ent)
		return HAM_IGNORED
	
	// Get distance between players
	static origin1[3], origin2[3]
	get_user_origin(Ent, origin1)
	get_user_origin(Attacker, origin2)
	
	// Max distance exceeded
	if (get_distance(origin1, origin2) > 1024)
		return HAM_IGNORED
		
	// Get victim's velocity
	static Float:velocity[3]
	pev(Ent, pev_velocity, velocity)
	
	// Use damage on knockback calculation
	xs_vec_mul_scalar(Dir, Damage, Dir)
	
	// Use weapon power on knockback calculation
	xs_vec_mul_scalar(Dir, float(2), Dir)
	
	// Apply ducking knockback multiplier
	new ducking = pev(Ent, pev_flags) & (FL_DUCKING | FL_ONGROUND) == (FL_DUCKING | FL_ONGROUND)
	if (ducking) xs_vec_mul_scalar(Dir, 0.5, Dir)
	
	// Add up the new vector
	xs_vec_add(velocity, Dir, Dir)
	
	// Should knockback also affect vertical velocity?
	Dir[2] = velocity[2]
	
	// Set the knockback'd victim's velocity
	set_pev(Ent, pev_velocity, Dir)
		
	return HAM_IGNORED
}
public fw_UpdateClientData_Post(id, sendweapons, cd_handle)
{
	if(!is_user_alive(id) || !is_user_connected(id))
		return FMRES_IGNORED
	if(get_user_weapon(id) != CSW_BUFFM95 || !g_had_buffm95[id])
		return FMRES_IGNORED
		
	set_cd(cd_handle, CD_flNextAttack, get_gametime() + 0.001) 
	
	return FMRES_HANDLED
}

public fw_PlaybackEvent(flags, invoker, eventid, Float:delay, Float:origin[3], Float:angles[3], Float:fparam1, Float:fparam2, iParam1, iParam2, bParam1, bParam2)
{
	if(!is_user_connected(invoker))
		return FMRES_IGNORED
		
	if(get_user_weapon(invoker) == CSW_BUFFM95 && g_had_buffm95[invoker] && eventid == g_buffm95_event)
	{
		engfunc(EngFunc_PlaybackEvent, flags | FEV_HOSTONLY, invoker, eventid, delay, origin, angles, fparam1, fparam2, iParam1, iParam2, bParam1, bParam2)	
		return FMRES_SUPERCEDE
	}
	
	return FMRES_HANDLED
}
public fw_Item_Deploy_Post(ent)
{
	static id; id = fm_cs_get_weapon_ent_owner(ent)
	if (!pev_valid(id))
		return HAM_IGNORED
	
	static weaponid
	weaponid = cs_get_weapon_id(ent)
	
	if(weaponid != CSW_BUFFM95)
		return HAM_IGNORED
	if(!g_had_buffm95[id])
		return HAM_IGNORED
	
	set_weapon_anim(id, 3)
	set_pdata_float(ent, 48, 1.0, 4)
	
	return HAM_IGNORED
}
public fw_Item_Idle_Post(ent)
{
	static Id; Id = get_pdata_cbase(ent, 41, 4)
	if(pev_valid(ent) != 2)
		return HAM_IGNORED
	if(get_pdata_cbase(Id, 373) != ent)
		return HAM_IGNORED
	if(!g_had_buffm95[Id])
		return HAM_IGNORED
	
	static Idle; Idle = 0
	if(Idle != -1 && get_pdata_float(ent, 48, 4) <= 0.25)
	{
		set_weapon_anim(Id, 0)
		set_pdata_float(ent, 48, 20.0, 4)
	}
	return HAM_IGNORED
}
public fw_Weapon_Reload_Pre(ent)
{
	static id; id = pev(ent, pev_owner)
	if(!pev_valid(ent))
		return HAM_IGNORED
	if(!g_had_buffm95[id])
		return HAM_IGNORED
	
	static iClip;iClip = get_pdata_int(ent, 51, 4)
	static bpammo; bpammo = cs_get_user_bpammo(id, CSW_BUFFM95)
	
	static iClipExtra

	if(g_had_buffm95[id])
		iClipExtra = CLIP
	
	g_buffm95_clip[id] = -1
	
	if (bpammo <= 0)
		return HAM_SUPERCEDE

	if (iClip >= iClipExtra)
		return HAM_SUPERCEDE

	g_buffm95_clip[id] = iClip
	
	return HAM_HANDLED
}
public fw_Weapon_Reload_Post(ent)
{
	static id; id = pev(ent, pev_owner)
	if(!pev_valid(ent))
		return HAM_IGNORED
	if(!g_had_buffm95[id])
		return HAM_IGNORED
	
	if (g_buffm95_clip[id] == -1)
		return HAM_IGNORED
	
	set_weapon_anim(id, 2)
	set_pdata_float(id, 83, RELOAD_TIME, 5)
	set_pdata_int(ent, 51, g_buffm95_clip[id], 4)
	set_pdata_int(ent, 54, 1, 4)
	make_zoom(id, 0)
	
	return HAM_HANDLED
}
public fw_Client_Command(id)
{
	new Cmd[32]
	read_argv(0, Cmd, 31)
	
	if(equal(Cmd, "lastinv") || equal(Cmd, "weapon_", 7))
		if(g_AttackType[id] == SHOOT_TIGER)return FMRES_SUPERCEDE
		
	return FMRES_IGNORED
}
public fw_Item_PostFrame(ent)
{
	static id
	new iButton = pev(id, pev_button)
	id = pev(ent, pev_owner)
	if(!pev_valid(ent))
		return
	
	if(!is_user_alive(id) && !g_had_buffm95[id])
		return
		
	static Float:flNextAttack; flNextAttack = get_pdata_float(id, 83, 5)
	static bpammo; bpammo = cs_get_user_bpammo(id, CSW_BUFFM95)
	static iClip; iClip = get_pdata_int(ent, 51, 4)
	static fInReload; fInReload = get_pdata_int(ent, 54, 4)
		
	if(fInReload && flNextAttack <= 0.0)
	{
		static temp1; temp1 = min(CLIP - iClip, bpammo)

		set_pdata_int(ent, 51, iClip + temp1, 4)
		cs_set_user_bpammo(id, CSW_BUFFM95, bpammo - temp1)		
			
		set_pdata_int(ent, 54, 0, 4)
			
		fInReload = 0		
	}
	if((iButton & IN_USE)) // Press E to shoot Tiger
	{
		if(!CanSummon)
			return
			
		set_weapon_anim(id, 4)
		PlaySound(id, sound[8])
		make_zoom(id, 0)
		CanSummon = 0
		iCount = 0
		set_fov(id, 100)
		g_AttackType[id] = SHOOT_TIGER
		SummonTiger(id)
		set_pdata_float(ent, 46, 2.7, 4)
		set_pdata_float(ent, 47, 2.7, 4)
		set_pdata_float(ent, 48, 3.7, 4)
		set_pdata_float(id, 83, 0.5, 5)
	}M95_Tiger_Config(id, ent, iButton)
}
public M95_Tiger_Config(id, ent, iButton)
{
	if(!is_user_alive(id) || get_user_weapon(id) != CSW_BUFFM95)
		return
	if(get_pdata_float(ent, 46, 4) > 0.0)
		return
	
	if(get_pdata_float(id, 83, 5) <= 0.0 && g_AttackType[id] == SHOOT_TIGER)
	{
		g_AttackType[id] = SHOOT_NORMAL
		set_fov(id, 90)
	}
	if(iCount == 9)
	{
		client_print(id, print_center, "You can Launch Tiger Now (E)")
		CanSummon = 1
	}
	if(iButton & IN_ATTACK)
	{
		if(g_AttackType[id] != SHOOT_NORMAL)
			return
			
		ExecuteHamB(Ham_Weapon_PrimaryAttack, ent)
		set_pdata_float(ent, 46, get_pdata_float(ent, 46, OFFSET_LINUX_WEAPONS) * SPEED, OFFSET_LINUX_WEAPONS)
		if(g_InZoom[id])make_zoom(id, 0)
		g_AttackType[id] = SHOOT_NORMAL
	}
	if(!(iButton & IN_ATTACK))
	{
		if(g_AttackType[id] == SHOOT_TIGER)
		{
			make_zoom(id, 0)
		}
	}
	if(iButton & IN_ATTACK2)
	{
		g_AttackType[id] = SHOOT_NET
		if(g_ammo_spc[id] && g_AttackType[id] == SHOOT_NET)
		{
			set_pdata_float(ent, 46, 1.7, 4)
			set_pdata_float(ent, 47, 1.7, 4)
			set_pdata_float(ent, 48, 3.7, 4)
			make_zoom(id, 0)
			Stock_Muzzle(id, sprites[4])
			g_ammo_spc[id]--
			g_AttackType[id] = SHOOT_NORMAL
			ShowStatusIcon(id, g_ammo_spc[id], 1)
			set_weapon_anim(id, 5)
			PlaySound(id, sound[7])
			Create_NetShit(id)
			make_puchangles(id)
		}
		else
		{
			g_AttackType[id] = SHOOT_NORMAL
			if(!g_InZoom[id])make_zoom(id, 1)
			else make_zoom(id, 0)
			set_pdata_float(ent, 46, 0.7, 4)
			set_pdata_float(ent, 47, 0.7, 4)
			set_pdata_float(ent, 48, 2.7, 4)
		}
	}
	iButton &= ~IN_ATTACK
	iButton &= ~IN_ATTACK2
	set_pev(id, pev_button, iButton)
}
public fw_think_nethit(iEnt)
{
	new id = pev(iEnt, pev_owner)
	if(!pev_valid(iEnt)) return FMRES_IGNORED
	
	set_pev(iEnt, pev_nextthink, get_gametime() + 0.05)
	static Float:fTimeRemove, Float:fFrame
	pev(iEnt, pev_ltime, fTimeRemove)
	pev(iEnt, pev_frame, fFrame)
	if(fFrame > 90.0)
	{
		fFrame = 0.0
	}
	fFrame += 2.5
	set_pev(iEnt, pev_frame, fFrame)
	if(get_gametime() >= fTimeRemove - 0.6)
	{
		static Float:fValue
		pev(iEnt, pev_renderamt, fValue)
		fValue = floatmax(fValue - 15.0, 0.0)
		set_pev(iEnt, pev_renderamt, fValue)
	}
	if(get_gametime() >= fTimeRemove) 
	{
		new Float:VicOri[3]
		for(new i = 0; i <get_maxplayers(); i++)
		{
			pev(i, pev_origin, VicOri)
			if(!is_user_alive(i))continue
			if(id == i)continue
			set_pev(i, pev_maxspeed, 320.0)
			if(g_Froze[i])g_Froze[i] = 0
		}
		if(pev_valid(g_InStuck[id]))set_pev(g_InStuck[id], pev_flags, pev(g_InStuck[id], pev_flags) | FL_KILLME)
	}
	
	return FMRES_IGNORED
}
public fw_think_net(iEnt)
{
	if(!pev_valid(iEnt)) return FMRES_IGNORED
	new id = pev(iEnt, pev_owner)
	set_pev(iEnt, pev_nextthink, get_gametime() + 0.05)
	static Float:fTimeRemove, Float:fFrame
	pev(iEnt, pev_ltime, fTimeRemove)
	pev(iEnt, pev_frame, fFrame)
	fFrame += 3.5
	set_pev(iEnt, pev_frame, fFrame)
	if(get_gametime() >= fTimeRemove - 0.6)
	{
		static Float:fValue
		pev(iEnt, pev_renderamt, fValue)
		fValue = floatmax(fValue - 15.0, 0.0)
		set_pev(iEnt, pev_renderamt, fValue)
	}
	if(entity_range(iEnt, id) > 750.0)set_pev(iEnt, pev_flags, pev(iEnt, pev_flags) | FL_KILLME)
	if(get_gametime() >= fTimeRemove) set_pev(iEnt, pev_flags, pev(iEnt, pev_flags) | FL_KILLME)
	return FMRES_IGNORED
}
public fw_touch_net(iEnt)
{
	static id; id = pev(iEnt, pev_owner)
	if(!pev_valid(iEnt))return
	
	Trigger_NetTrap(iEnt, id)
}
public Trigger_NetTrap(iEnt, id)
{
	new Float:VicOri[3]
	for(new i = 0; i <32; i++)
	{
		pev(i, pev_origin, VicOri)
		if(!is_user_alive(i))continue
		if(get_user_team(id) == get_user_team(i))continue
		if(entity_range(iEnt, i) >= 60.0)continue
		netShit2(id, i, VicOri, "net_hit", "models/ef_m95tiger_nethit.mdl")
		set_pev(i, pev_maxspeed, 0.01)
		set_pev(i, pev_origin, VicOri)
		remove_entity_name("net_shot")
	}
}
public netShit2(iIdx, iVic, Float:Origin3[3], szclassname[], szmodel[])
{
	g_InStuck[iIdx] = engfunc(EngFunc_CreateNamedEntity, engfunc(EngFunc_AllocString, "info_target"))
	static Ent; Ent = g_InStuck[iIdx]
	if(!pev_valid(Ent)) return
	
	if(!g_Froze[iVic])g_Froze[iVic] = 1
	
	pev(iVic, pev_origin, Origin3)
	set_pev(Ent, pev_movetype, MOVETYPE_NONE)
	set_pev(Ent, pev_solid, SOLID_NOT)
	set_pev(Ent, pev_owner, iIdx)
	set_pev(Ent, pev_origin, Origin3)
	set_pev(Ent, pev_classname, szclassname)
	engfunc(EngFunc_SetModel, Ent, szmodel)
	set_pev(Ent, pev_sequence, 0)
	set_pev(Ent, pev_animtime, get_gametime())
	set_pev(Ent, pev_framerate, 1.0)
	set_pev(Ent, pev_rendermode, kRenderTransAdd)
	set_pev(Ent, pev_renderamt, 255.0)
	set_pev(Ent, pev_light_level, 180.0)
	set_pev(Ent, pev_ltime, get_gametime()+1.7)
	
	set_pev(Ent, pev_nextthink, get_gametime()+0.05)
}
public Create_NetShit(id)
{
	new Float:vOrigin[3], Float:vAngles[3], Float:vVec[3]
	pev(id, pev_origin, vOrigin)
	Stock_SetVelocity(id, 1200.0, vVec)
	
	new iEnt = engfunc(EngFunc_CreateNamedEntity, engfunc(EngFunc_AllocString, "info_target"))
	set_pev(iEnt, pev_classname, "net_shot")
	engfunc(EngFunc_SetModel, iEnt, "models/ef_m95tiger_net.mdl")
	set_pev(iEnt, pev_origin, vOrigin)
	set_pev(iEnt, pev_solid, SOLID_TRIGGER)
	set_pev(iEnt, pev_movetype, MOVETYPE_NOCLIP)
	set_pev(iEnt, pev_rendermode, kRenderTransAdd)
	set_pev(iEnt, pev_renderamt, 255.0)
	set_pev(iEnt, pev_light_level, 180.0)
	set_pev(iEnt, pev_animtime, get_gametime())
	set_pev(iEnt, pev_gravity, 0.01)
	Stock_SetSequence(iEnt, 0)
	set_pev(iEnt, pev_velocity, vVec)
	Stock_GetVelocityAngle(iEnt, vAngles)
	set_pev(iEnt, pev_angles, vAngles)
	set_pev(iEnt, pev_owner, id)
	
	set_pev(iEnt, pev_ltime, get_gametime() + 2.0)
	set_pev(iEnt, pev_nextthink, get_gametime() + 0.05)
	
	engfunc(EngFunc_SetSize, iEnt, Float:{-15.0, -15.0, 0.0}, Float:{15.0, 15.0, 15.0})
}
public fw_tgr_think(iEnt)
{
	if(!pev_valid(iEnt)) return FMRES_IGNORED
	
	set_pev(iEnt, pev_nextthink, get_gametime() + 0.05)
	static Float:fTimeRemove, fFrame
	pev(iEnt, pev_ltime, fTimeRemove)
	pev(iEnt, pev_frame, fFrame)
	fFrame += 2.5
	set_pev(iEnt, pev_frame, fFrame)
	if(get_gametime() >= fTimeRemove - 0.6)
	{
		static Float:fValue
		pev(iEnt, pev_renderamt, fValue)
		fValue = floatmax(fValue - 15.0, 0.0)
		set_pev(iEnt, pev_renderamt, fValue)
	}
	if(get_gametime() >= fTimeRemove) set_pev(iEnt, pev_flags, pev(iEnt, pev_flags) | FL_KILLME)
	return FMRES_IGNORED
}
public fw_tgr_touch(iEnt, Touch)
{
	static id; id = pev(iEnt, pev_owner)
	if(!pev_valid(iEnt))
		return FMRES_IGNORED
		
	new Float:VicOri[3]
	for(new i = 0; i <32; i++)
	{
		pev(i, pev_origin, VicOri)
		if(!is_user_alive(i))continue
		if(get_user_team(id) == get_user_team(i))continue
		if(entity_range(iEnt, i) > 120.0)continue
		
		ExecuteHamB(Ham_TakeDamage, i, fm_get_user_weapon_entity(id, CSW_BUFFM95), id, DAMAGE_CLAW, DMG_SLASH)
		MakeEffectSpr(5, 20, VicOri)
	}
	return FMRES_IGNORED
}
public SummonTiger(id)
{
	new Float:vOrigin[3], Float:vAngles[3], Float:vVec[3]
	pev(id, pev_origin, vOrigin)
	Stock_SetVelocity(id, 750.0, vVec)
	
	new iEnt = engfunc(EngFunc_CreateNamedEntity, engfunc(EngFunc_AllocString, "info_target"))
	set_pev(iEnt, pev_classname, "ef_tiger")
	engfunc(EngFunc_SetModel, iEnt, "models/ef_m95tiger.mdl")
	set_pev(iEnt, pev_origin, vOrigin)
	set_pev(iEnt, pev_solid, SOLID_TRIGGER)
	set_pev(iEnt, pev_movetype, MOVETYPE_NOCLIP)
	set_pev(iEnt, pev_rendermode, kRenderTransAdd)
	set_pev(iEnt, pev_renderamt, 255.0)
	set_pev(iEnt, pev_animtime, get_gametime())
	set_pev(iEnt, pev_gravity, 0.01)
	Stock_SetSequence(iEnt, 0)
	set_pev(iEnt, pev_velocity, vVec)
	Stock_GetVelocityAngle(iEnt, vAngles)
	set_pev(iEnt, pev_angles, vAngles)
	set_pev(iEnt, pev_owner, id)
	
	set_pev(iEnt, pev_ltime, get_gametime() + 120.0)
	set_pev(iEnt, pev_nextthink, get_gametime() + 0.05)
	engfunc(EngFunc_SetSize, iEnt, Float:{-50.0, -50.0, 0.0}, Float:{50.0, 50.0, 50.0})
	
	client_cmd(id, "spk %s", sound[5])
}
public fw_Item_AddToPlayer_Post(ent, id)
{
	if(!pev_valid(ent))
		return HAM_IGNORED
		
	if(pev(ent, pev_impulse) == weapon_code)
	{
		g_had_buffm95[id] = 1
		set_pev(ent, pev_impulse, 0)
	}
	
	return HAM_IGNORED
}
public fw_Weapon_PrimaryAttack_Pre(ent)
{
	static id; id = pev(ent, pev_owner)
	if(!pev_valid(ent))
		return HAM_IGNORED
	if(!g_had_buffm95[id])
		return HAM_IGNORED
	if(g_AttackType[id] != SHOOT_NORMAL)
		return HAM_IGNORED
		
	pev(id, pev_punchangle, g_punchangles[id])
	
	return HAM_IGNORED
}
public fw_Weapon_PrimaryAttack_Post(ent)
{
	static iClip;iClip = get_pdata_int(ent, 51, 4)
	static id; id = pev(ent, pev_owner)
	if(!pev_valid(ent))
		return HAM_IGNORED
	if(!g_had_buffm95[id])
		return HAM_IGNORED
		
	if (iClip <= 0)
		return HAM_IGNORED
	if(g_AttackType[id] != SHOOT_NORMAL)
		return HAM_IGNORED
		
	make_puchangles(id)
	Check_Damage(id)
	set_weapon_anim(id, 1)
	PlaySound(id, sound[6])
	Stock_Muzzle(id, sprites[4])
	g_AttackType[id] = SHOOT_NORMAL
	
	return HAM_HANDLED
}
public make_puchangles(id)
{
	static Float:VirtualVec[3]
	VirtualVec[0] = random_float(-3.5, -7.0)
	VirtualVec[1] = random_float(3.0, -3.0)
	VirtualVec[2] = 0.0
	
	set_pev(id, pev_punchangle, VirtualVec)
}
public Check_Damage(id)
{
	static Float:StartOrigin[3], Float:EndOrigin[3], Float:EndOrigin2[3]
	
	if(get_cvar_num("cl_righthand"))
	{
		Stock_Get_Postion(id, 40.0, 7.5, -5.0, StartOrigin)
	} else {
		Stock_Get_Postion(id, 40.0, -7.5, -5.0, StartOrigin)
	}
	Stock_Get_Postion(id, 4096.0, 0.0, 0.0, EndOrigin)
	
	static TrResult; TrResult = create_tr2()
	engfunc(EngFunc_TraceLine, StartOrigin, EndOrigin, IGNORE_MONSTERS, id, TrResult) 
	get_tr2(TrResult, TR_vecEndPos, EndOrigin2)
	free_tr2(TrResult)
	
	message_begin(MSG_BROADCAST, SVC_TEMPENTITY)
	write_byte(TE_BEAMPOINTS)
	engfunc(EngFunc_WriteCoord, StartOrigin[0])
	engfunc(EngFunc_WriteCoord, StartOrigin[1])
	engfunc(EngFunc_WriteCoord, StartOrigin[2])
	engfunc(EngFunc_WriteCoord, EndOrigin2[0])
	engfunc(EngFunc_WriteCoord, EndOrigin2[1])
	engfunc(EngFunc_WriteCoord, EndOrigin2[2])
	write_short(g_Beam_SprId)
	write_byte(0)
	write_byte(0)
	write_byte(10)
	write_byte(25)
	write_byte(0)
	write_byte(240)
	write_byte(240)
	write_byte(0)
	write_byte(180)
	write_byte(0)
	message_end()	

	message_begin(MSG_BROADCAST, SVC_TEMPENTITY)
	write_byte(TE_SPARKS) //TE_SPARKS
	engfunc(EngFunc_WriteCoord, EndOrigin2[0])
	engfunc(EngFunc_WriteCoord, EndOrigin2[1])
	engfunc(EngFunc_WriteCoord, EndOrigin2[2])
	message_end()	
	
	ChargedDamage(id, StartOrigin, EndOrigin2)
}
public MakeEffectSpr(Size, Framerate, Float:Origin[3])
{
	static TE_FLAG
	
	TE_FLAG |= TE_EXPLFLAG_NODLIGHTS
	TE_FLAG |= TE_EXPLFLAG_NOSOUND
	TE_FLAG |= TE_EXPLFLAG_NOPARTICLES
		
	message_begin(MSG_BROADCAST, SVC_TEMPENTITY)
	write_byte(TE_EXPLOSION)
	engfunc(EngFunc_WriteCoord, Origin[0])
	engfunc(EngFunc_WriteCoord, Origin[1])
	engfunc(EngFunc_WriteCoord, Origin[2] - 10.0)
	write_short(g_hit)
	write_byte(Size)
	write_byte(Framerate) 
	write_byte(TE_FLAG) 
	message_end()
}
public ChargedDamage(id, Float:Start[3], Float:End[3])
{
	
	static TrResult; TrResult = create_tr2()
	static Ent; Ent = fm_get_user_weapon_entity(id, CSW_BUFFM95)
	// get fDirection
	new Float:fAngles[3], Float:fDirection[3]
	pev(id, pev_angles, fAngles)
	angle_vector(fAngles, ANGLEVECTOR_FORWARD, fDirection)
    
	// Trace First Time
	engfunc(EngFunc_TraceLine, Start, End, DONT_IGNORE_MONSTERS, id, TrResult) 
	static pHit1; pHit1 = get_tr2(TrResult, TR_pHit)
	static Float:End1[3]; get_tr2(TrResult, TR_vecEndPos, End1)
    
	if(is_user_alive(pHit1)) 
	{
		do_attack(id, pHit1, Ent, float(DAMAGE) * 1.5)
		fake_trake_attack(id, pHit1, float(DAMAGE), fDirection, TrResult)
		engfunc(EngFunc_TraceLine, End1, End, DONT_IGNORE_MONSTERS, pHit1, TrResult) 
	} else engfunc(EngFunc_TraceLine, End1, End, DONT_IGNORE_MONSTERS, -1, TrResult) 
    
	// Trace Second Time
	static pHit2; pHit2 = get_tr2(TrResult, TR_pHit)
	static Float:End2[3]; get_tr2(TrResult, TR_vecEndPos, End2)
    
	if(is_user_alive(pHit2)) 
	{
		do_attack(id, pHit2, Ent, float(DAMAGE) * 1.5)
		fake_trake_attack(id, pHit2, float(DAMAGE), fDirection, TrResult)
		engfunc(EngFunc_TraceLine, End2, End, DONT_IGNORE_MONSTERS, pHit2, TrResult) 
	} else engfunc(EngFunc_TraceLine, End2, End, DONT_IGNORE_MONSTERS, -1, TrResult) 
    
	// Trace Third Time
	static pHit3; pHit3 = get_tr2(TrResult, TR_pHit)
	static Float:End3[3]; get_tr2(TrResult, TR_vecEndPos, End3)
    
	if(is_user_alive(pHit3)) 
	{
		do_attack(id, pHit3, Ent, float(DAMAGE) * 1.5)
		fake_trake_attack(id, pHit3, float(DAMAGE), fDirection, TrResult)
		engfunc(EngFunc_TraceLine, End3, End, DONT_IGNORE_MONSTERS, pHit3, TrResult) 
	} else engfunc(EngFunc_TraceLine, End3, End, DONT_IGNORE_MONSTERS, -1, TrResult) 
    
	// Trace Fourth Time
	static pHit4; pHit4 = get_tr2(TrResult, TR_pHit)
	if(is_user_alive(pHit4)) do_attack(id, pHit4, Ent, float(DAMAGE) * 1.5)
    
	if(iCount < 10)iCount++
	else iCount = 0

	free_tr2(TrResult)
}
ShowStatusIcon(id, idspr, On)
{	
	HideStatusIcon(id)
	if(idspr) StatusIcon(id, idspr, On)
}
HideStatusIcon(id)
{	
	for (new i = 1; i <= 9; i++)
	{
		StatusIcon(id, i, 0)
	}

}
StatusIcon(id, idspr, On)
{	
	static AmmoSprites[33]
	format(AmmoSprites, sizeof(AmmoSprites), "number_%d", idspr)
  	
	message_begin(MSG_ONE_UNRELIABLE, g_Msg_StatusIcon, {0,0,0}, id)
	write_byte(On)
	write_string(AmmoSprites)
	write_byte(42) // red
	write_byte(212) // green
	write_byte(255) // blue
	message_end()

}
public fw_Muzzle_Think(iEnt)
{
	if(!pev_valid(iEnt))
		return
	
	static Owner; Owner = pev(iEnt, pev_owner)
	
	if(!is_user_alive(Owner))
	{
		set_pev(iEnt, pev_flags, FL_KILLME)
		return
	}
	if(get_user_weapon(Owner) != CSW_BUFFM95)
	{
		set_pev(iEnt, pev_flags, FL_KILLME)
		return
	}
	
	static iActiveItem; iActiveItem = get_pdata_cbase(Owner, 373, 5)
	
	if(!IsValidPev(iActiveItem))
	{
		set_pev(iEnt, pev_flags, FL_KILLME)
		return
	}

	static Float:Frame; pev(iEnt, pev_frame, Frame)
	if(Frame > 16.0) 
	{
		set_pev(iEnt, pev_flags, FL_KILLME)
		return
	}
	else
	{
		Frame += 0.7
		set_pev(iEnt, pev_frame, Frame)
	}
	
	set_pev(iEnt, pev_nextthink, get_gametime() + 0.04)
}
//stock
stock Stock_SetSequence(iEnt, iSeq, Float:fFramerate = 1.0)
{
	if(!pev_valid(iEnt)) return 0
	
	set_pev(iEnt, pev_animtime, get_gametime())
	set_pev(iEnt, pev_frame, 0.0)
	set_pev(iEnt, pev_framerate, fFramerate)
	set_pev(iEnt, pev_sequence, iSeq)
	return 1
}
stock Stock_SetVelocity(id, Float:fMulti, Float:vVelocity[3], Float:fAngleOffset=0.0)
{
	static Float:vAngle[3]
	pev(id, pev_v_angle, vAngle)
	if(fAngleOffset != 0.0) vAngle[0] += fAngleOffset
	angle_vector(vAngle, ANGLEVECTOR_FORWARD, vAngle)
	xs_vec_mul_scalar(vAngle, fMulti, vVelocity)
}
stock Stock_GetVelocityAngle(id, Float:fOutput[3])
{
	static Float:vVelocity[3]
	pev(id, pev_velocity, vVelocity)
	vector_to_angle(vVelocity, fOutput)
	if(fOutput[0] > 90.0) fOutput[0] = -(360.0 - fOutput[0])
}
stock Stock_Buff(id,spr,scale)
{
	new vOri[3]
	if(id<33 && pev_valid(id))
	{
		get_user_origin(id,vOri,0)
		if(is_user_alive(id))
		{
			message_begin(MSG_BROADCAST,SVC_TEMPENTITY)
			write_byte(TE_SPRITE)
			write_coord(vOri[0])
			write_coord(vOri[1])
			write_coord(vOri[2])
			write_short(spr)
			write_byte(scale)
			write_byte(255)
			message_end()
		}
	}
}
do_attack(Attacker, Victim, Inflictor, Float:fDamage)
{
	fake_player_trace_attack(Attacker, Victim, fDamage)
	fake_take_damage(Attacker, Victim, fDamage, Inflictor)
}

fake_player_trace_attack(iAttacker, iVictim, &Float:fDamage)
{
	// get fDirection
	new Float:fAngles[3], Float:fDirection[3]
	pev(iAttacker, pev_angles, fAngles)
	angle_vector(fAngles, ANGLEVECTOR_FORWARD, fDirection)
	
	// get fStart
	new Float:fStart[3], Float:fViewOfs[3]
	pev(iAttacker, pev_origin, fStart)
	pev(iAttacker, pev_view_ofs, fViewOfs)
	xs_vec_add(fViewOfs, fStart, fStart)
	
	// get aimOrigin
	new iAimOrigin[3], Float:fAimOrigin[3]
	get_user_origin(iAttacker, iAimOrigin, 3)
	IVecFVec(iAimOrigin, fAimOrigin)
	
	// TraceLine from fStart to AimOrigin
	new ptr; ptr = create_tr2() 
	engfunc(EngFunc_TraceLine, fStart, fAimOrigin, DONT_IGNORE_MONSTERS, iAttacker, ptr)
	new pHit; pHit = get_tr2(ptr, TR_pHit)
	new iHitgroup; iHitgroup = get_tr2(ptr, TR_iHitgroup)
	new Float:fEndPos[3]
	get_tr2(ptr, TR_vecEndPos, fEndPos)

	// get target & body at aiming
	new iTarget, iBody
	get_user_aiming(iAttacker, iTarget, iBody)
	
	// if aiming find target is iVictim then update iHitgroup
	if (iTarget == iVictim)
	{
		iHitgroup = iBody
	}
	
	// if ptr find target not is iVictim
	else if (pHit != iVictim)
	{
		// get AimOrigin in iVictim
		new Float:fVicOrigin[3], Float:fVicViewOfs[3], Float:fAimInVictim[3]
		pev(iVictim, pev_origin, fVicOrigin)
		pev(iVictim, pev_view_ofs, fVicViewOfs) 
		xs_vec_add(fVicViewOfs, fVicOrigin, fAimInVictim)
		fAimInVictim[2] = fStart[2]
		fAimInVictim[2] += get_distance_f(fStart, fAimInVictim) * floattan( fAngles[0] * 2.0, degrees )
		
		// check aim in size of iVictim
		new iAngleToVictim; iAngleToVictim = get_angle_to_target(iAttacker, fVicOrigin)
		iAngleToVictim = abs(iAngleToVictim)
		new Float:fDis; fDis = 2.0 * get_distance_f(fStart, fAimInVictim) * floatsin( float(iAngleToVictim) * 0.5, degrees )
		new Float:fVicSize[3]
		pev(iVictim, pev_size , fVicSize)
		if ( fDis <= fVicSize[0] * 0.5 )
		{
			// TraceLine from fStart to aimOrigin in iVictim
			new ptr2; ptr2 = create_tr2() 
			engfunc(EngFunc_TraceLine, fStart, fAimInVictim, DONT_IGNORE_MONSTERS, iAttacker, ptr2)
			new pHit2; pHit2 = get_tr2(ptr2, TR_pHit)
			new iHitgroup2; iHitgroup2 = get_tr2(ptr2, TR_iHitgroup)
			
			// if ptr2 find target is iVictim
			if ( pHit2 == iVictim && (iHitgroup2 != HIT_HEAD || fDis <= fVicSize[0] * 0.25) )
			{
				pHit = iVictim
				iHitgroup = iHitgroup2
				get_tr2(ptr2, TR_vecEndPos, fEndPos)
			}
			
			free_tr2(ptr2)
		}
		
		// if pHit still not is iVictim then set default HitGroup
		if (pHit != iVictim)
		{
			// set default iHitgroup
			iHitgroup = HIT_GENERIC
			
			new ptr3; ptr3 = create_tr2() 
			engfunc(EngFunc_TraceLine, fStart, fVicOrigin, DONT_IGNORE_MONSTERS, iAttacker, ptr3)
			get_tr2(ptr3, TR_vecEndPos, fEndPos)
			
			// free ptr3
			free_tr2(ptr3)
		}
	}
	
	// set new Hit & Hitgroup & EndPos
	set_tr2(ptr, TR_pHit, iVictim)
	set_tr2(ptr, TR_iHitgroup, iHitgroup)
	set_tr2(ptr, TR_vecEndPos, fEndPos)

	// ExecuteHam
	fake_trake_attack(iAttacker, iVictim, fDamage, fDirection, ptr)
	
	// free ptr
	free_tr2(ptr)
}
stock bool:can_see_fm(entindex1, entindex2)
{
	if (!entindex1 || !entindex2)
		return false

	if (pev_valid(entindex1) && pev_valid(entindex1))
	{
		new flags = pev(entindex1, pev_flags)
		if (flags & EF_NODRAW || flags & FL_NOTARGET)
		{
			return false
		}

		new Float:lookerOrig[3]
		new Float:targetBaseOrig[3]
		new Float:targetOrig[3]
		new Float:temp[3]

		pev(entindex1, pev_origin, lookerOrig)
		pev(entindex1, pev_view_ofs, temp)
		lookerOrig[0] += temp[0]
		lookerOrig[1] += temp[1]
		lookerOrig[2] += temp[2]

		pev(entindex2, pev_origin, targetBaseOrig)
		pev(entindex2, pev_view_ofs, temp)
		targetOrig[0] = targetBaseOrig [0] + temp[0]
		targetOrig[1] = targetBaseOrig [1] + temp[1]
		targetOrig[2] = targetBaseOrig [2] + temp[2]

		engfunc(EngFunc_TraceLine, lookerOrig, targetOrig, 0, entindex1, 0) //  checks the had of seen player
		if (get_tr2(0, TraceResult:TR_InOpen) && get_tr2(0, TraceResult:TR_InWater))
		{
			return false
		} 
		else 
		{
			new Float:flFraction
			get_tr2(0, TraceResult:TR_flFraction, flFraction)
			if (flFraction == 1.0 || (get_tr2(0, TraceResult:TR_pHit) == entindex2))
			{
				return true
			}
			else
			{
				targetOrig[0] = targetBaseOrig [0]
				targetOrig[1] = targetBaseOrig [1]
				targetOrig[2] = targetBaseOrig [2]
				engfunc(EngFunc_TraceLine, lookerOrig, targetOrig, 0, entindex1, 0) //  checks the body of seen player
				get_tr2(0, TraceResult:TR_flFraction, flFraction)
				if (flFraction == 1.0 || (get_tr2(0, TraceResult:TR_pHit) == entindex2))
				{
					return true
				}
				else
				{
					targetOrig[0] = targetBaseOrig [0]
					targetOrig[1] = targetBaseOrig [1]
					targetOrig[2] = targetBaseOrig [2] - 17.0
					engfunc(EngFunc_TraceLine, lookerOrig, targetOrig, 0, entindex1, 0) //  checks the legs of seen player
					get_tr2(0, TraceResult:TR_flFraction, flFraction)
					if (flFraction == 1.0 || (get_tr2(0, TraceResult:TR_pHit) == entindex2))
					{
						return true
					}
				}
			}
		}
	}
	return false
}
stock make_zoom(id, zoom)
{
	if(!is_user_alive(id))
		return
	if(!g_had_buffm95[id])
		return
	
	switch(zoom)
	{
		case 0:
		{
			g_InZoom[id] = 0
			cs_set_user_zoom(id, CS_RESET_ZOOM, 0)
		}
		case 1:
		{
			g_InZoom[id] = 1
			cs_set_user_zoom(id,CS_SET_FIRST_ZOOM, 0)
		}
	}
}
stock Aim_To(iEnt, Float:vTargetOrigin[3], Float:flSpeed, Style)
{
	if(!pev_valid(iEnt))	
		return
		
	if(!Style)
	{
		static Float:Vec[3], Float:Angles[3]
		pev(iEnt, pev_origin, Vec)
		
		Vec[0] = vTargetOrigin[0] - Vec[0]
		Vec[1] = vTargetOrigin[1] - Vec[1]
		Vec[2] = vTargetOrigin[2] - Vec[2]
		engfunc(EngFunc_VecToAngles, Vec, Angles)
		Angles[0] = Angles[2] = 0.0 
		
		set_pev(iEnt, pev_v_angle, Angles)
		set_pev(iEnt, pev_angles, Angles)
	} else {
		new Float:f1, Float:f2, Float:fAngles, Float:vOrigin[3], Float:vAim[3], Float:vAngles[3];
		pev(iEnt, pev_origin, vOrigin);
		xs_vec_sub(vTargetOrigin, vOrigin, vOrigin);
		xs_vec_normalize(vOrigin, vAim);
		vector_to_angle(vAim, vAim);
		
		if (vAim[1] > 180.0) vAim[1] -= 360.0;
		if (vAim[1] < -180.0) vAim[1] += 360.0;
		
		fAngles = vAim[1];
		pev(iEnt, pev_angles, vAngles);
		
		if (vAngles[1] > fAngles)
		{
			f1 = vAngles[1] - fAngles;
			f2 = 360.0 - vAngles[1] + fAngles;
			if (f1 < f2)
			{
				vAngles[1] -= flSpeed;
				vAngles[1] = floatmax(vAngles[1], fAngles);
			}
			else
			{
				vAngles[1] += flSpeed;
				if (vAngles[1] > 180.0) vAngles[1] -= 360.0;
			}
		}
		else
		{
			f1 = fAngles - vAngles[1];
			f2 = 360.0 - fAngles + vAngles[1];
			if (f1 < f2)
			{
				vAngles[1] += flSpeed;
				vAngles[1] = floatmin(vAngles[1], fAngles);
			}
			else
			{
				vAngles[1] -= flSpeed;
				if (vAngles[1] < -180.0) vAngles[1] += 360.0;
			}		
		}
	
		set_pev(iEnt, pev_v_angle, vAngles)
		set_pev(iEnt, pev_angles, vAngles)
	}
}


stock FindClosesEnemy(entid)
{
	new Float:Dist
	new Float:maxdistance=300.0
	new indexid=0	
	for(new i=1;i<=get_maxplayers();i++){
		if(is_user_alive(i) && is_valid_ent(i) && can_see_fm(entid, i)
		&& pev(entid, pev_owner) != i && cs_get_user_team(pev(entid, pev_owner)) != cs_get_user_team(i))
		{
			Dist = entity_range(entid, i)
			if(Dist <= maxdistance)
			{
				maxdistance=Dist
				indexid=i
				
				return indexid
			}
		}	
	}	
	return 0
}
stock StopSound(id)
{
	ExecuteHamB(Ham_Weapon_PlayEmptySound, id)
}
stock fake_trake_attack(iAttacker, iVictim, Float:fDamage, Float:fDirection[3], iTraceHandle, iDamageBit = (DMG_NEVERGIB | DMG_BULLET))
{
	ExecuteHamB(Ham_TraceAttack, iVictim, iAttacker, fDamage, fDirection, iTraceHandle, iDamageBit)
}

stock fake_take_damage(iAttacker, iVictim, Float:fDamage, iInflictor, iDamageBit = (DMG_NEVERGIB | DMG_BULLET))
{
	ExecuteHamB(Ham_TakeDamage, iVictim, iInflictor, iAttacker, fDamage, iDamageBit)
}

stock get_angle_to_target(id, const Float:fTarget[3], Float:TargetSize = 0.0)
{
	new Float:fOrigin[3], iAimOrigin[3], Float:fAimOrigin[3], Float:fV1[3]
	pev(id, pev_origin, fOrigin)
	get_user_origin(id, iAimOrigin, 3) // end position from eyes
	IVecFVec(iAimOrigin, fAimOrigin)
	xs_vec_sub(fAimOrigin, fOrigin, fV1)
	
	new Float:fV2[3]
	xs_vec_sub(fTarget, fOrigin, fV2)
	
	new iResult; iResult = get_angle_between_vectors(fV1, fV2)
	
	if (TargetSize > 0.0)
	{
		new Float:fTan; fTan = TargetSize / get_distance_f(fOrigin, fTarget)
		new fAngleToTargetSize; fAngleToTargetSize = floatround( floatatan(fTan, degrees) )
		iResult -= (iResult > 0) ? fAngleToTargetSize : -fAngleToTargetSize
	}
	
	return iResult
}

stock get_angle_between_vectors(const Float:fV1[3], const Float:fV2[3])
{
	new Float:fA1[3], Float:fA2[3]
	engfunc(EngFunc_VecToAngles, fV1, fA1)
	engfunc(EngFunc_VecToAngles, fV2, fA2)
	
	new iResult; iResult = floatround(fA1[1] - fA2[1])
	iResult = iResult % 360
	iResult = (iResult > 180) ? (iResult - 360) : iResult
	
	return iResult
}
stock Stock_Get_Postion(id,Float:forw,Float:right, Float:up,Float:vStart[])
{
	static Float:vOrigin[3], Float:vAngle[3], Float:vForward[3], Float:vRight[3], Float:vUp[3]
	
	pev(id, pev_origin, vOrigin)
	pev(id, pev_view_ofs,vUp) //for player
	xs_vec_add(vOrigin,vUp,vOrigin)
	pev(id, pev_v_angle, vAngle) // if normal entity ,use pev_angles
	
	angle_vector(vAngle,ANGLEVECTOR_FORWARD,vForward) //or use EngFunc_AngleVectors
	angle_vector(vAngle,ANGLEVECTOR_RIGHT,vRight)
	angle_vector(vAngle,ANGLEVECTOR_UP,vUp)
	
	vStart[0] = vOrigin[0] + vForward[0] * forw + vRight[0] * right + vUp[0] * up
	vStart[1] = vOrigin[1] + vForward[1] * forw + vRight[1] * right + vUp[1] * up
	vStart[2] = vOrigin[2] + vForward[2] * forw + vRight[2] * right + vUp[2] * up
} 

stock PlaySound(id, Soundd[])
{
	if (!Soundd[0])
		return;
	
	client_cmd(id, "spk %s", Soundd)
}
stock Stock_Muzzle(iPlayer, szmodel[])
{
	static Ent; Ent = engfunc(EngFunc_CreateNamedEntity, engfunc(EngFunc_AllocString, "info_target"))
	if(!pev_valid(Ent)) return
	
	set_pev(Ent, pev_classname, "mf_buffm95")
	
	set_pev(Ent, pev_owner, iPlayer)
	set_pev(Ent, pev_body, 1)
	set_pev(Ent, pev_skin, iPlayer)
	set_pev(Ent, pev_aiment, iPlayer)
	set_pev(Ent, pev_movetype, MOVETYPE_FOLLOW)
	
	set_pev(Ent, pev_scale, 0.095)
	set_pev(Ent, pev_frame, 0.0)
	set_pev(Ent, pev_rendermode, kRenderTransAdd)
	set_pev(Ent, pev_renderamt, 255.0)
	
	engfunc(EngFunc_SetModel, Ent,  szmodel)
	
	set_pev(Ent, pev_nextthink, get_gametime() + 0.04)
}
stock fm_cs_get_weapon_ent_owner(ent)
{
	if (pev_valid(ent) != PDATA_SAFE)
		return -1
	
	return get_pdata_cbase(ent, OFFSET_WEAPONOWNER, OFFSET_LINUX_WEAPONS)
}

stock set_weapon_anim(id, iAnim)
{
	if(!is_user_alive(id))
		return
		
	if (!is_user_alive(id) || iAnim < 0) return;
	
	set_pev(id, pev_weaponanim, iAnim)
	
	message_begin(MSG_ONE_UNRELIABLE, SVC_WEAPONANIM, _, id)
	write_byte(iAnim)
	write_byte(pev(id, pev_body))
	message_end()	
}

stock drop_weapons(id, dropwhat)
{
	// Get user weapons
	static weapons[32], num, i, weaponid
	num = 0 // reset passed weapons count (bugfix)
	get_user_weapons(id, weapons, num)
	
	// Loop through them and drop primaries or secondaries
	for (i = 0; i < num; i++)
	{
		// Prevent re-indexing the array
		weaponid = weapons[i]
		
		if ((dropwhat == 1 && ((1<<weaponid) & PRIMARY_WEAPONS_BIT_SUM)) || (dropwhat == 2 && ((1<<weaponid) & SECONDARY_WEAPONS_BIT_SUM)))
		{
			// Get weapon entity
			static wname[32]; get_weaponname(weaponid, wname, charsmax(wname))
			engclient_cmd(id, "drop", wname)
		}
	}
}
stock set_fov(id, iFov)
{
	if(!is_user_connected(id))
		return
		
	message_begin(MSG_ONE_UNRELIABLE, get_user_msgid("SetFOV"), _, id)
	write_byte(iFov)
	message_end
}
stock make_bullet(id, Float:Origin[3])
{
	// Find target
	new decal = random_num(41, 45)
	const loop_time = 2
	
	static Body, Target
	get_user_aiming(id, Target, Body, 999999)
	
	if(is_user_connected(Target))
		return
	
	for(new i = 0; i < loop_time; i++)
	{
		// Put decal on "world" (a wall)
		message_begin(MSG_BROADCAST, SVC_TEMPENTITY)
		write_byte(TE_WORLDDECAL)
		engfunc(EngFunc_WriteCoord, Origin[0])
		engfunc(EngFunc_WriteCoord, Origin[1])
		engfunc(EngFunc_WriteCoord, Origin[2])
		write_byte(decal)
		message_end()
		
		// Show sparcles
		message_begin(MSG_BROADCAST, SVC_TEMPENTITY)
		write_byte(TE_GUNSHOTDECAL)
		engfunc(EngFunc_WriteCoord, Origin[0])
		engfunc(EngFunc_WriteCoord, Origin[1])
		engfunc(EngFunc_WriteCoord, Origin[2])
		write_short(id)
		write_byte(decal)
		message_end()
	}
}

public fake_smoke(id, trace_result)
{
	static Float:vecSrc[3], Float:vecEnd[3], TE_FLAG
	
	get_weapon_attachment(id, vecSrc)
	global_get(glb_v_forward, vecEnd)
    
	xs_vec_mul_scalar(vecEnd, 8192.0, vecEnd)
	xs_vec_add(vecSrc, vecEnd, vecEnd)

	get_tr2(trace_result, TR_vecEndPos, vecSrc)
	get_tr2(trace_result, TR_vecPlaneNormal, vecEnd)
    
	xs_vec_mul_scalar(vecEnd, 2.5, vecEnd)
	xs_vec_add(vecSrc, vecEnd, vecEnd)
    
	TE_FLAG |= TE_EXPLFLAG_NODLIGHTS
	TE_FLAG |= TE_EXPLFLAG_NOSOUND
	TE_FLAG |= TE_EXPLFLAG_NOPARTICLES
	
	engfunc(EngFunc_MessageBegin, MSG_PAS, SVC_TEMPENTITY, vecEnd, 0)
	write_byte(TE_EXPLOSION)
	engfunc(EngFunc_WriteCoord, vecEnd[0])
	engfunc(EngFunc_WriteCoord, vecEnd[1])
	engfunc(EngFunc_WriteCoord, vecEnd[2] - 10.0)
	write_short(g_smokepuff_id)
	write_byte(2)
	write_byte(50)
	write_byte(TE_FLAG)
	message_end()
}
stock Stock_GetSpeedVector(const Float:origin1[3], const Float:origin2[3], Float:speed, Float:new_velocity[3])
{
	xs_vec_sub(origin2, origin1, new_velocity)
	new Float:num = floatsqroot(speed * speed / (new_velocity[0] * new_velocity[0] + new_velocity[1] * new_velocity[1] + new_velocity[2] * new_velocity[2]))
	xs_vec_mul_scalar(new_velocity, num, new_velocity)
}
stock get_weapon_attachment(id, Float:output[3], Float:fDis = 40.0)
{ 
	new Float:vfEnd[3], viEnd[3] 
	get_user_origin(id, viEnd, 3)  
	IVecFVec(viEnd, vfEnd) 
	
	new Float:fOrigin[3], Float:fAngle[3]
	
	pev(id, pev_origin, fOrigin) 
	pev(id, pev_view_ofs, fAngle)
	
	xs_vec_add(fOrigin, fAngle, fOrigin) 
	
	new Float:fAttack[3]
	
	xs_vec_sub(vfEnd, fOrigin, fAttack)
	xs_vec_sub(vfEnd, fOrigin, fAttack) 
	
	new Float:fRate
	
	fRate = fDis / vector_length(fAttack)
	xs_vec_mul_scalar(fAttack, fRate, fAttack)
	
	xs_vec_add(fOrigin, fAttack, output)
}

stock create_blood(const Float:origin[3])
{
	// Show some blood :)
	message_begin(MSG_BROADCAST, SVC_TEMPENTITY) 
	write_byte(TE_BLOODSPRITE)
	engfunc(EngFunc_WriteCoord, origin[0])
	engfunc(EngFunc_WriteCoord, origin[1])
	engfunc(EngFunc_WriteCoord, origin[2])
	write_short(m_iBlood[1])
	write_short(m_iBlood[0])
	write_byte(75)
	write_byte(5)
	message_end()
}
